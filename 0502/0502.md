# 트랜잭션 만들기 (2)

## 3번째 블록만들기

블록을 생성하기 위해서 아래와 같은 내용이 필요하다.

-   이전 블록에 대한 내용을 알아야하고 : 높이가 2인 블록
-   10번째 블록에 대한 내용을 알아야한다. : 제네시스블록

블록이 생성되는 시간의 텀은 10분정도가 있다.
그 10분간 일어나는 일중에 하나가 여러 거래이다.
그래서 TX Pool이라는 공간에 처리되지 않은 거래들이 담겨있다.

블록을 생성할 떄, 머클루트라는 것이 있기 때문에 블록을 생성하겠다라는 의미는 기존에 있던 트랜잭션을 이용해서 만든다.
예를들어, 2번블록이 9시 10분에 생성이 됐고 3번블록이 9시 20분에 생성이 된다했을 떄,
3번 블록에 포함되는 트랜잭션은 2번블록이 생성되는 시기, 즉 9시~9시10분에 만들어진 트랜잭션들을 포함할 수 있다.

트랜잭션이 만들어지기 위해서 필요한 내용은 트랜잭션의 영수증이다.
영수증을 이용해서 트랜잭션을 만들 수 있다.

## 총 발행량

제네시스 블록, 블록2, 블록 3
총 3개를 만들면서 sender와, received의 잔액은
70, 30이 되었다.
채굴을 하면서 블록이 생성될 때 보상이 주어지기 때문에, 블록 2,3번에 대한 보상이 주어졌다. 그래서 코인의 총 통화량이 100개이며, 그 중에 30을 received에 보내주었기 때문에, 70,30 으로 잔액이 남는다.

## 트랜잭션 최적화

기존의 코드를 이용하면 직관적이지 않고, 트랜잭션을 만드는 것도 메서드를 하나하나 찾아서 작성해야하는 불편함이 있다.

그래서 receipt 객체가 하나 주어지면 이를 이용해서 트랜잭션을 만들 수 있도록 함수로 따로 관리하는 것이 좋다.

```ts
// index.ts
// TxIn
const txin1 = transaction.createTxIn(1, "", receipt.signature)
// TxOut
// 총수량 - amount
const txout_sender = transaction.createTxOut(receipt.sender.account, 50 - receipt.amount)
const txout_received = transaction.createTxOut(receipt.received, receipt.amount)

const tx1 = transaction.createRow([txin1], [txout_sender, txout_received])
```

이렇게 작성되었던 코드를 아래와 같이 따로 함수로 뺄 수 있다.
tranasaction.ts에서 작성되기 때문에 trasaction.~~~는
this.~~로 바뀐다.

```ts
// transaction.ts
create(receipt: Receipt) {
    const totalAmount = 50
    // TxIn
    const txin1 = this.createTxIn(1, "", receipt.signature)
    // TxOut
    // 총수량 - amount
    const txout_sender = this.createTxOut(receipt.sender.account, 50 - receipt.amount)
    const txout_received = this.createTxOut(receipt.received, receipt.amount)
    return this.createRow([txin1], [txout_sender, txout_received])
}

//index.ts
const tx2 = transaction.create(receipt)

```

index에서 간편하게 쓰기 위해서 tx1을 만드는 메서드들을 transaction.ts에서 함수를 이용해서 작성하고 index.ts에서 조금더 쉽게 tx를 생성할 수 있다.

## 미사용 트랜잭션 (UnspentTxOuts)

```ts
create(receipt: Receipt) {
    const totalAmount = 50
    const txin1 = this.createTxIn(1, "", receipt.signature)
}
```

위의 creat() 함수에서 잔액을 하드코딩으로 작성하였다.
하지만 이 부분을 따로 구현할 수 있다. 나의 잔액을 구하는 로직이 있어야 하는데, UTXO를 만드는 것이다.

```
예, 맞습니다. 제공된 create() 함수에서 totalAmount는 값 50으로 하드 코딩됩니다. 그러나 실제 블록체인 애플리케이션에서는 계정의 잔액이 하드 코딩되지 않고 대신 결정됩니다. 계정과 연결된 미사용 트랜잭션 출력(UTXO)을 조사하여 동적으로


UTXO 모델을 사용하는 블록체인 네트워크에서 각 트랜잭션 출력은 특정 계정과 연결된 특정 양의 암호화폐를 나타냅니다. 트랜잭션이 생성되면 특정 UTXO를 입력으로 참조하고 새 UTXO를 출력으로 생성합니다. 계정의 잔액을 결정하려면 해당 계정과 연결된 모든 UTXO의 합계를 계산해야 합니다.


따라서 계정의 잔고를 정확하게 결정하는 'create()' 함수를 생성하기 위해서는 해당 계정과 관련된 UTXO를 검색하는 별도의 로직을 구현해야 합니다. 여기에는 특정 공개 키 또는 주소와 관련된 UTXO에 대한 블록체인 네트워크 쿼리 또는 특정 계정과 관련된 UTXO를 추적하는 로컬 UTXO 데이터베이스 유지 관리가 포함될 수 있습니다.
```

사진....

tx4->tx5
세욱의 사용하지 않은 UTXO를 구해야한다.

output 데이터 중에서 input으로 들어간 내용을 삭제한다.

Txout중에서 사용하지 않는 객체들을 모아놓은 것이 잔액이다.

사용을 했는지 안했는지에 대한 내용을 어떻게 확인할 것인가?

transactionRow에 hash값이 있다..
이 hash는 트랜잭션의 고유 식별자이다.

txOutId만 존재하는 것은 코인베이스를 의미한다.

미사용객체(UTXO)에서 input으로 객체가 사용되는 순간
미사용객체에서는 삭제된다.

미사용객체만 이용해도 거래를 가능한지, 잔액이 얼마인지를 알 수 있다.

똑같은 형태로 미사용객체들이 구현되기 때문에 미사용객체의 인터페이스가 필요하고 이를 배열로 만들어서 관리할 것이다.

```ts
export class UnspentTxOut {
    txOutId!: string
    txOutIndex!: number
    account!: string
    amount!: number
}

export type UnspentTxOutPool = UnspentTxOut[]
export type TransactionPool = TransactionRow[]
```

미사용 객체들을 모아둔 곳을 UnspentTxOutPool, 트랜잭션들을 모아두는 곳을 TransactionPool로 작성한다.

UnspentTxOutPool,UnspentTxOut[] 두개의 데이터 형태는 같지만
UnspentTxOutPool은 완성된 실제로 사용할 UTXO객체라고 생각하면 된다.
