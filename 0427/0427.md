블록을 만드는 과정을 이어서 배울예정임

1. createBlock()

생성 속도롤 확인해서 난이도를 조절한다.

# 작업 증명

(pow, pos, poa)
내가 블럭을 만들 수 잇는 사람과 아닌 사람을 증명하는 과정이다..

adjustmentBlock의 역할
~이기 때문에 블록의 형태로 받았다.

### 작업 증명에 대해서 좀 알아보기

-   POW Proof of Work의 약자이다.
    작업증명

연산을 누가 더 빨리 작업을 하는가?를 판단

POS : Proof of Stake
지분증명

코인을 많이 가지고 있는 사람이 블럭을 만들수 있다.(탈중앙화에서 맞는 개념인가가..)

POA : Proof of Authority
권한증명

선택한 사람만 블록을 생성할 수 있다. 블록체인 작업에서 좋은 작업이라고 할 수 없다..
블록체인은 public과 private으로 있는데, 일반적인 블록체인은 public인데, private는 노드를 아무나 참여할 수 없다.
coov는 블록체인 기술로 만들었지만, private 였다.
private 는 일반적으로 노드의 갯수가 현저히 떨어져서, 속도는 빠르지만, 노드의 갯수가 적기때문에 보안성의 떨어진다.
private의 대표적인 프로젝트는 하이퍼레저라고 있다. did 신원인증, 회사내에서만 정보를 찾아서 작업을 해야하기 때문에 private를 이용한다.

작업증명의 종류에 따라서 로직이 다르지만
증명하는 로직은 있을 것이다.

그렇기 때문에 POW, POS에서 어떤 증명이든 일반적인 증명에 대한 로직은 있어야한다.

OOP의 디자인패턴 중 하나인 전략패턴을 사용해서 작업을 한다.

여러 증명이 있는데 상황에 따라서 갈아 끼우는 로직을 하고 싶기 때문이다.

전략패턴이 많이 쓰이는 곳이, 웹쪽에서의 로그인 로직을 구현할 때 많이 쓰인다.
세부적인 로그인 형태가 많기 때문에 ..

나중에 로그인 로직을 구현 할 때 전략패턴을 이용하여 사용한다.

로그인 관련 처리를 할 때 passport 라이브러리를 많이 싸용하는데, 이 passport 라이브러리도 전략패턴으로 만들어져있다.

# 작업 증명 구현

작업 증명을 구현할 것이다.
POW를 구현할 것인데, 추후에 POS로 바뀌는 상황을 생각하여 전략패턴으로 구현할 예정이다.

## 1. WorkProof 클래스 생성

WorkProof/WorkProof.ts 에 WorkProof 클래스 생성
이후 block.ts에 매개변수로 의존성 주입을 한다.

```ts
constructor(private readonly crypto: CryptoModule, private readonly workProof: WorkProof) {}

```

1. 조건문을 이용하여 분기처리를 한다.

2. 새로운 파일을 만들어서 클래스를 상속하고 이를 이용해서 새로운 클래스를 만들어서 확장시켜서 사용을 한다.

기능이 추가 되었을 때 하나의 클래스를 추가해서 작업을 하자..

new WorkProof()를 했을 때 POW를 진행하고 싶을 때 new ProofOfWork()를 WorkProof()에 의존성 주입을 받는다.

```ts
class WorkProof {
    constructor(private readonly work: ProofOfWork) {}
    run(type: string) {
        if (type === "pow") console.log("blsock hello")
    }
}

const work = new ProofOfWork()
new WorkProof(work)
```

이렇게 주입을 하게 되면 POW에서 POS로 바꾸는 과정이 힘들다.

이를 해결할기 위해서

한가지 인터페이스를 만들어서 POW, Pos 클래스를 인터페이스로 확장을 해서 분기처리를 한다.

### 테스트 코드로 확인하기.

workpoof.test.ts

# class 설계

Express Class로 만드는것이 힘든이유..

ERD처럼 class 도 설계를 할 때 UML이라는 모델링 작업을 한다.
