# 협약 프로젝트

-   출석률

-   점심시간 이후에 프로젝트 관련되서 지갑프로젝트 내용으로..!

# Ethereum

비트코인은 블록체인이라는 개념을 알기위한 것이였고, 궁극적으로 배워야할 것이 이더리움이다.
블록체인이라는 것을 배울 때 기본적으로 백서를 보고 배운다.

백서 = 솔루션(프로그램)에 대해서 만든사람이 어떤식으로 만들 것인지 상세하게 적어둔 것을 말한다.
한번 읽어보는 것이 좋다.

이더리움도 똑같이 백서라는 것이 있다. ethereum의 공식 깃허브 wiki에 있다.

**차세대 스마트 컨트랙트와 탈중화된 어플리케이션 플랫폼**

-   스마트 컨트랙트
-   어플리케이션 플랫폼
    이 두개가 중요한 키워드이다.

**비트코인**을 보면 결제에 포커스가 많이 맞춰져있다.
하지만 **이더리움**은 결제에 포커스가 맞춰져있지 않다.

블록체인 네트워크(생태계)를 활용해서 어플리케이션(웹사이트)을 쉽게 만들어주는 플랫폼을 이더리움의 목적이다.

백서에 이더리움이 제공하려는 것은 완벽한 튜링완전 프로그래밍 언어가 심어진 블록체인이다.

> 튜링완전

> 앨런 튜링에 의해 만들어졌고

> 계산 가능한 문제를 해결할 수 있는 모든 기계의 공통된 능력

> 연산 가능한건지 불가능한건지 .. 계산이 된다면 계산을 하고, 계산이 안되면 안한다. 라는 말과 같다.

> 1+1 (O), 1+닭(x)

백서의 역사, 이더리움에 대해서 조금 봐두면 좋다.
밑에는 거의 이더리움으로 무엇을 만들 수 있는지에 대해서만 적어둔거다.

## 목차

-   역사(비트코인에 대해서..)
    -   생태변환 시스템으로써 비트코인
    -   채굴
    -   머클트리
    -   스크립팅
-   이더리움
    -   이더리움 Account
    -   이더리움 Transaction
    -   이더리움 코드실행
    -   이더리움 블록체인과 채굴

### 역사

이더리움이 POS로 넘어간 이유는

-   그룹형성
-   전력 소비 낭비
    POW의 장점이자 가장 큰 특징인 누구나 채굴 할 수 있다는 문제를 악용하여, 마이너가 그룹을 만들어서 작업을 하는 문제가 생겼다.
    여러 사람들이 그룹을 만들어서 해시파워가 커지면 이 블록체인 생태계를 그 그룹이 장악하는 사태가 생긴다. 이것을 중앙화가 된것 아니냐는 주장이 생김.
    POW의 단점인 자원의 낭비가 심하다(마이닝하는 동안 전기료가 어마어마...)

이더리움에서 State라는 것이 나오는데, 이더리움의 State는 비트코인의 UTXO와 잔액을 확인할 수 있다는 과정은 비슷하다지만 다른 과정을 이용한다.

### 상태

쇼핑몰을 구현할 때

1. 상품테이블
2. 유저테이블
3. 오더테이블 (state)

### 스크립팅

블록체인을 말하면 이더리움에서 스마트 컨트랙트, 솔리디티라는 단어가 많이 언급이 된다.

**Smart Contract** 뜻을
A -> B
C
A가 B에게 무언가를 줄때, C의 서명을 갖고 거래가 가능하다.
C : 중개업자 같은 역할이라고 납득할 수 있다.

A서명, C서명을 이용해야 A가 트랜잭션을 발동할 수 있다.

A가 100을 가지고 있을 때 B에게 20을 준다고하면 A의 요구사항이 처리가 되었을 때 C에게 입금된 20에 대한 내용을 사용할 수 있다.

1. 튜링불안정성
2. 다양한 값을 표현할 수 없다.
3. 블록체인을 해독할 수 없다.
    - 검증을 할 수 없다.

이런 단점을 해결하기 위해서 이더리움을 만들엇다..?

## 이더리움

이더리움의 목적은 분산 어플리케이션 제작을 위한 대체 **프로토콜**을 만드는 것이다.
블록체인을 이용해서 무언가를 만든다 하면 이더리움으로 만든 것이라고 생각하면된다.
탈중앙화된 프로그램을 만드는 것을 `Dapp`이라고 한다.

월렛을 만든 것을 Dapp이라고 할 수 있다.(데이터를 블록체인 네트워크에서 가지고 오기 떄문에!)

은행 역할을 할 수 있나?
이더리움은 블록체인 플랫폼 역할을 하고 있기 때문에
이 플랫폼을 하기위해서 튜링완정성

### 이더리움 Account

이더리움에서의 Account는 **상태** **Account**

```ts
interface Transaction {
    nonce: number
    balance: string
    storageRoot: string
    codeHash: string
}
transaction()
```

```ts
const 0x0001 = {
    nonce:0
    balance : 10
}
```

트랜잭션이 발동되면 상태가 바뀐다.
0x00001:10btc -> TX -> 0x00001:8btc,0x00002:2btc

UTXO처럼 +,-가 쌓이는 것이아닌 상태가 업데이트가 된다.
그래서 검증하는 과정이 어렵다.

트랜잭션이 발동되면 nonce값을 증가시킨다.
nonce 값을 이용하여 이중지불을 막을 수 있다.

1ETH = 10E+18 = 1000000000000000000

wei 최소단위를 말한다. gwei
1 ETH -> 다른 사람에게 보내려할때, 1을 적는 것이 아닌. 1\*(10^18)로 작성해야한다.

getBalance를 가져올 때 UTXO

Account 납득하기

Account에는 2가지 타입이 있다.
account가 사용이 됐냐 안됐냐에 따라서

-   EOA : (Externally Owned Account) : 프라이빗 키에 통제되는 외부 소유 account - 계정으로 돈을 옮기고 싶을 떄, 사용자끼리 거래를 하는 과정에서, 서명을 이용해서 거래를 진행한다.
-   CA : (Contract Account) : Contract가 담겨있는 계정 - 프라이빗 키가 존재하지 않는다.
    -   nonce, balance, storageRoot, codeHash 요소를 가지고 있다.

스마트 컨트랙트를 작성한다 : 코드를 작성한다. 이 작성한 코드를 codeHash에 담는다.

```ts
interface Transaction {
    nonce: number // 각 트랜잭션에 오직 한번만 처리되는 것 (이중지불을 막기위함)
    balance: string // 이더잔액
    storageRoot: string // 스마트 컨트랙트의 데이터를 저장하는 공간
    codeHash: string // 스마트컨트랙트 코드
}
```

```ts
class Counter {
    private count: number = 0

    constructor() {}

    getCount() {
        return this.count
    }

    setCount(_count) {
        this.count = _count
    }
}
```
