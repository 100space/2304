# 협약 프로젝트

-   출석률

-   점심시간 이후에 프로젝트 관련되서 지갑프로젝트 내용으로..!

# Ethereum

비트코인은 블록체인이라는 개념을 알기위한 것이였고, 궁극적으로 배워야할 것이 이더리움이다.
블록체인이라는 것을 배울 때 기본적으로 백서를 보고 배운다.

백서 = 솔루션(프로그램)에 대해서 만든사람이 어떤식으로 만들 것인지 상세하게 적어둔 것을 말한다.
한번 읽어보는 것이 좋다.

이더리움도 똑같이 백서라는 것이 있다. ethereum의 공식 깃허브 wiki에 있다.

**차세대 스마트 컨트랙트와 탈중화된 어플리케이션 플랫폼**

-   스마트 컨트랙트
-   어플리케이션 플랫폼
    이 두개가 중요한 키워드이다.

**비트코인**을 보면 결제에 포커스가 많이 맞춰져있다.
하지만 **이더리움**은 결제에 포커스가 맞춰져있지 않다.

블록체인 네트워크(생태계)를 활용해서 어플리케이션(웹사이트)을 쉽게 만들어주는 플랫폼을 이더리움의 목적이다.

백서에 이더리움이 제공하려는 것은 완벽한 튜링완전 프로그래밍 언어가 심어진 블록체인이다.

> 튜링완전

> 앨런 튜링에 의해 만들어졌고

> 계산 가능한 문제를 해결할 수 있는 모든 기계의 공통된 능력

> 연산 가능한건지 불가능한건지 .. 계산이 된다면 계산을 하고, 계산이 안되면 안한다. 라는 말과 같다.

> 1+1 (O), 1+닭(x)

백서의 역사, 이더리움에 대해서 조금 봐두면 좋다.
밑에는 거의 이더리움으로 무엇을 만들 수 있는지에 대해서만 적어둔거다.

## 목차

-   역사(비트코인에 대해서..)
    -   생태변환 시스템으로써 비트코인
    -   채굴
    -   머클트리
    -   스크립팅
-   이더리움
    -   이더리움 Account
    -   이더리움 Transaction
    -   이더리움 코드실행
    -   이더리움 블록체인과 채굴

### 역사

이더리움이 POS로 넘어간 이유는

-   그룹형성
-   전력 소비 낭비
    POW의 장점이자 가장 큰 특징인 누구나 채굴 할 수 있다는 문제를 악용하여, 마이너가 그룹을 만들어서 작업을 하는 문제가 생겼다.
    여러 사람들이 그룹을 만들어서 해시파워가 커지면 이 블록체인 생태계를 그 그룹이 장악하는 사태가 생긴다. 이것을 중앙화가 된것 아니냐는 주장이 생김.
    POW의 단점인 자원의 낭비가 심하다(마이닝하는 동안 전기료가 어마어마...)

이더리움에서 State라는 것이 나오는데, 이더리움의 State는 비트코인의 UTXO와 잔액을 확인할 수 있다는 과정은 비슷하다지만 다른 과정을 이용한다.

### 상태

쇼핑몰을 구현할 때

1. 상품테이블
2. 유저테이블
3. 오더테이블 (state)

### 스크립팅

블록체인을 말하면 이더리움에서 스마트 컨트랙트, 솔리디티라는 단어가 많이 언급이 된다.

**Smart Contract** 뜻을
A -> B
C
A가 B에게 무언가를 줄때, C의 서명을 갖고 거래가 가능하다.
C : 중개업자 같은 역할이라고 납득할 수 있다.

A서명, C서명을 이용해야 A가 트랜잭션을 발동할 수 있다.

A가 100을 가지고 있을 때 B에게 20을 준다고하면 A의 요구사항이 처리가 되었을 때 C에게 입금된 20에 대한 내용을 사용할 수 있다.

1. 튜링불안정성
2. 다양한 값을 표현할 수 없다.
3. 블록체인을 해독할 수 없다.
    - 검증을 할 수 없다.

이런 단점을 해결하기 위해서 이더리움을 만들엇다..?

## 이더리움

이더리움의 목적은 분산 어플리케이션 제작을 위한 대체 **프로토콜**을 만드는 것이다.
블록체인을 이용해서 무언가를 만든다 하면 이더리움으로 만든 것이라고 생각하면된다.
탈중앙화된 프로그램을 만드는 것을 `Dapp`이라고 한다.

월렛을 만든 것을 Dapp이라고 할 수 있다.(데이터를 블록체인 네트워크에서 가지고 오기 떄문에!)

은행 역할을 할 수 있나?
이더리움은 블록체인 플랫폼 역할을 하고 있기 때문에
이 플랫폼을 하기위해서 튜링완정성

### 이더리움 Account

이더리움에서의 Account는 **상태** **Account**

```ts
interface Account {
    nonce: number
    balance: string
    storageRoot: string
    codeHash: string
}
transaction()
```

```ts
const 0x0001 = {
    nonce:0
    balance : 10
}
```

트랜잭션이 발동되면 상태가 바뀐다.
0x00001:10btc -> TX -> 0x00001:8btc,0x00002:2btc

UTXO처럼 +,-가 쌓이는 것이아닌 상태가 업데이트가 된다.
그래서 검증하는 과정이 어렵다.

트랜잭션이 발동되면 nonce값을 증가시킨다.
nonce 값을 이용하여 이중지불을 막을 수 있다.

1ETH = 10E+18 = 1000000000000000000

wei 최소단위를 말한다. gwei
1 ETH -> 다른 사람에게 보내려할때, 1을 적는 것이 아닌. 1\*(10^18)로 작성해야한다.

getBalance를 가져올 때 UTXO

Account 납득하기

Account에는 2가지 타입이 있다.
account가 사용이 됐냐 안됐냐에 따라서

-   EOA : (Externally Owned Account) : 프라이빗 키에 통제되는 외부 소유 account - 계정으로 돈을 옮기고 싶을 떄, 사용자끼리 거래를 하는 과정에서, 서명을 이용해서 거래를 진행한다.
-   CA : (Contract Account) : Contract가 담겨있는 계정 - 프라이빗 키가 존재하지 않는다.
    -   nonce, balance, storageRoot, codeHash 요소를 가지고 있다.

스마트 컨트랙트를 작성한다 : 코드를 작성한다. 이 작성한 코드를 codeHash에 담는다.

```ts
interface Account {
    nonce: number // 각 트랜잭션에 오직 한번만 처리되는 것 (이중지불을 막기위함)
    balance: string // 이더잔액
    storageRoot: string // 스마트 컨트랙트의 데이터를 저장하는 공간
    codeHash: string // 스마트컨트랙트 코드
}
```

```ts
class Counter {
    private count: number = 0

    constructor() {}

    getCount() {
        return this.count
    }

    setCount(_count) {
        this.count = _count
    }
}

const counter = new Counter()
counter.setCount(5)
console.log(counter.count) // 5
```

```solidity
pragma solidity ^0.8.0;

contract Count {
    unit256 value;
    unit256 value2;
    unit256 value3;


    function getValue() public view returns(unit256){
        return value
    }

    function setValue(unit256 _value) public {
        value = _value
    }
}
```

key - value 형태로 쌍을 이루어서 데이터를 저장한다.
value = 0, value2 = 0, value3 = 0,

## 메세지와 트랜잭션

이더리움에서는 signature(서명)이 있는 Receipt(영수증)을 Transaction이라고 말한다.

이더리움에서는 receipt를 가공하지 않고 바로 사용한다.
비트코인에서는 receipt를 이용해서 Tx를 만들었다. 두 요소가 달랐지만
이더리움에서는 receipt를 바로 Tx로 사용한다.
비트코인은 UTXO가 있기 때문에 사용할 수 있는 형태로 가공하는 과정이 필요했다.

Signature(서명)이 없는 Receipt(영수증)을 Message(메세지)라고한다.

```ts
interface Message {
    from?: string // 기본 구성
    to: string // 기본 구성
    value?: numbers // 기본 구성

    hash?: string
    nonce?: number // 검증을 위해서

    gas?: number // 수수료
    gasPrice?: number //수수료

    data?: string //to에 ca계정이 들어오게 되면 필요한 값
}

interface Transaction extends Message {
    //SignatureInput
    v: number
    r: string
    s: string
}
```

영수증을 이용해서 트랜잭션을 만들고, 이 트랜잭션을 이용해서 블록을 만든다.
이 블록을 이용해서 상태를 바뀌게 된다.
from에 대한 사람만 nonce값이 증가되고, 받는 사람인 to의 계정은 nonce의 값이 올라가지 않는다.
블록의 높이가 올라가면서 account가 생성된다.

비트코인은 mempool, 이더리움은 txpool이라고 한다.
누군가 나보다 트랜잭션을 더 늦게 발동하더라도, 가스(수수료)가 높을수록 우선순위를 가진다.

고정된 수수료 값이 아니다. 그래서 이더리움의 단점이 수수료가 비싸다는 점이다.

## gas

주유소에서 1L당 적힌 금액이 있다.
예를 들어 1L당 1716원이라고 가정했을 때,
3만원을 넣는다는 가정을 하면, 17.4825L를 넣을 수 있다.

이것이 가스 측정 방식이다.
gasPrice - 1L당 가격인 1716 // 내가 지정할 수 있음
gas - 총 주유량이다. 17.4825 // 내가 지정할 수 없음 // min - 21000

총 수수료는( gas X gasPrice)

가스라는 것은 재측정이 되는데, TX들이 블록에 담길때, 총 사용가스량이 다시 측정이 된다.

내가 총 낼 수수료를 작성하지만 다시 측정이 되고, smart contract, 튜링완전, 반복문,
스마트 컨트랙트에 for 문을 작성했다고 가정했을 때, 1~10, 1~1000까지 반복한다.
하지만 실수로 무한루프를 돌리게 되면, 이더리움은 완전튜링을 했지만, 무한루프 같은 문제를 해결하기 위해서 가스라는 것이 있다.

연산이 될 때 마다 가스가 발생한다.
대부분 1byte당 5gas가 소비된다. 기본 21000이 있기 때문에 21015가스를 발생한다.
3만을 측정하더라도, 21015 \* gasPrice를 한 값이 fee( 수수료 )로 측정이된다.

애초에 블록에다가도 gaslimit를 지정햊둔다. 총 사용량 : 블록에 담긴 모든 트랜잭션으로 결정된다.

기본적으로 내 코드가 얼만큼의 가스를 소비해야하는지 알아야하기 때문에 TDD를 사용하게 된다.

gaslimit 를 넘게 되면 다음 트랜잭션은 다음 블록에 포함되게 된다.

수수료는 그냥 사라지는 것이아닌 , 채굴자에게 기본 보상 + 수수료로 준다.

이더리움은 화폐에 대한 포커스가 아니여서 코인 발행 갯수가 지정되지 않았었는데, 소각기능을 이용해서 양을 최대한 유지할 수 있도록한다.

## 스마트컨트랙트

코드를 작성하는 것은 블록체인 네트워크랑 관계가 없지만 이를 실행시킬 때는 블록체인 네트워크가 중요하다.

-   step1. 내PC에서 코드를 작성한다. comfile을 진행한다. (평문 -> byte 코드)

### 순서.

코드를 작성하여 byteCode로 컴파일 진행시켜 데이터로 만든 후 영수증의 data에 포함되어 TX를 만든다.

tx를 만들어 txpool에 들어가서 대기한다 ( 이때는 아직 코드 상태로 가지고 있다..)

내 트랜잭션이 처리될 떄 , 블록에 들어가기 전에 코드를 실행한다.
solidity 언어로 작성된 코드를 실행하기 위해서 EVM이라는 실행기를 이용해서 코드가 실행이된다.

코드가 실행되면서 인스턴스가 생성된다 .(스마트 컨트랙트는 클래스 형태로 작성되기 때문에 인스턴스 생성이 된다.)

그후에 account가 생성되며, 이때 생성되는 account 는 CA이다.

이 account는 nonce, balance,codehash 이 포함된다.

내가 한번 짠 코드는 블록에 포함되어 블록체인 네트워크에 포함되므로 수정이 불가능 하다.

내일 스마트컨트랙트를 counter로 만들어서 할 것이다.

## EVM

ethereum virtual machine의 약자로 이더리움의 스마트 컨트렉트를 위한 런타임 환경이다.
하드웨어가 하고 있는 일은 소프트웨어로 구현이 가능한데 (CPU, MEMORY, HardDisk) 이를 가능하게 하는 것을 VM이라고 한다.

각 노드들이 EVM을 가지고 있다. 각 노드는 내용(코드)을 전달 받게 되면 EVM으로 실행한다.

1. solidity 생성, 컴파일

-   smart contract를 실행하기 전에 contract compile 하여 EVM이 이해할 수 있도록 변환함

2. Transaction 생성/서명 (수수료 발생)

-   EVM이 이해할 수 있는 Compile 된 내용을 Transaction.data 부분에 넣고 Transaction 생성

3. Gas 소비

-   Miner에 의해 EVM을 통해 Bytecode가 해석되고, 이때 Gas량이 측저오딘다.

4. 코드실행

-   contract 인스턴스 생성(한번 배포하면 1개의 인서턴스만 존재한다.)

5. 상태 변경
   -contract 기본상태 설정 및 변경
   `value`값
6. 트랜잭션 완성

## 블록체인과 채굴

Transaction 한개당 UTXO 한번 실행
Transaction을 만나게 되면 Account 내용을 최신화를 진행한다.
그리고 새로운 transaction 만나면 최신화된 account 에서 다시 새로운 account 만들어짐
