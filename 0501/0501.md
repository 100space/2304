전자 서명은 블록체인 뿐 아니라 여러군데에서 사용하며, 결제같은 영역에서 내가 나임을 증명하는 것이다.

## 예시

A -> B에게 2btc를 주려고 할 때 내가 A임을 증명하는것이다.

내 돈이 감소하고 상대방 돈이 증가함했다는 것으로 트랜잭션이 일어난다.

앞으로 만들 것은 트랜잭션을 만드는 것이다

# 트랜잭션

트랜잭션 -> 블록체인 네트워크에서 어떤식으로 돌아가냐..?

노드가 하나가 있을 때, 노드 안에 기본적으로 블록들이 저장되어 있다.(체인형태로)

A라는 사람이 B에게 2BTC를 주려고 헀을때, A가 A임을 증명하는(서명)과정이 진행 된 후

온라인에서는 A라는 사람이 B에게 바로 다이렉트로 주는 것이 아니고,

-   1. A가 B에게 준다는 내용의 정보(영수증)를 Node에게 전달을 한다.

-   2. 그러면 node는 그 영수증을 가지고 사용자가 맞는지 검증한후,

-   3. A의 잔고를 확인한다.

-   4. 트랜잭션을 생성한다

    -   트랜잭션이 생성이 되면 바로 진행되는 것이 아니다.

-   5. 생성된 트랜잭션은 TX Pool 이라는 공간에 블록에 담기길 기다린다.

-   6. TX pool에 담겼다고 과정이 완료되는 것이 아니다.

    -   이 시점에도 B의 잔액이 나오지 않는다.

-   7. 마이닝을 하면서 마이닝의 데이터로 내 트랜젝션을 포함할 떄, 거래가 완료된다.

잔액이라는 숫자도 모든 거래내역을 연산한 후에 보여주는 것이다. 블록안의 트랜잭션들을 가지고 한다.

1채굴에 걸리는 시간을 10분이라고 생각했기 때문에 최소 10분의 시간이 걸린다.
마이닝을 빨리 할 수 있도록 한다.
마이닝을 빨리하려면 데이터를 최소화한다.
그러면 담을 수 있는 내용이 줄어든다.

TX : 트랜잭션이고, 하나의 객체이다.

영수증이라는 데이터를 가지고 트랜잭션으로 바꾸는 과정도 코드량이 많을 것이다.

채굴하는 과정을 만들었는데, 새로운 블럭을 만들 때, 머클루트라는 값이 있는데 이 때 데이터를 이용해서 머클루트를 만든다.
이 데이터들은 배열로 이루어져있는데, 이 배열안에 TX가 들어간다. TX는 TX Pool에서 가져오며, 비트코인은 1000~2000개의 TX를 이용해서 만든다.

채굴(마이닝)을 하게 되면 보상이라는 것이 있다.

마이닝을 하는 사람에게 일정 보상을 주기 때문에 하나의 TX로 만들어서 포함되며,
입금 내역만 존재한다. 누군가의 비트코인에서 차감해서 주는 것이 아닌 새로운 TX를 주는것이다. 코인베이스라고한다.

코인베이스 : 채굴을 하기 전에 , 트랜잭션 풀에서 처리할 거래 내역을 가지고 마이닝을 하는데, 이 때, 마이닝을 하는 사람은 지갑을 생성한 사람만 마이닝을 할 수 있다.(받을 계좌번호가 있어야 보상을 해준다.)

개인키는 필요없고 account만 있으면 된다.

일반적인 트랜잭션의 경우 플러스와 마이너스가 있어야하지만, 보상에 대해서는 플러스의 내용만 있기 때문에 조금은 다른 형태를 이룬다. [코인베이스]

영수증을 가지고 TX 객체 모양이 어떻게 생겼는지 알아야한다.

# 트랜잭션 객체

입금과 출금에 대한 내용이 있을 때

입금을 TXinput, 출금을 TXoutput으로 설정한다.
out은 어떤 데이터가 포함되냐.
input은 누구의 돈이 얼마나 들어오냐,
output은 누구의 돈이 얼마나 나가냐에 대한 내용이 있어야한다.

tx input, tx output을 합쳐서 TX가 된다.

A라는 사람이 50원이 들어오고 20원이 나간 데이터가 있고,
B라는 사람이 20원이 들어오는 데이터가 있다고 했을 떄,

TX객체는 노드 기준으로 작성이된다.

```
TX{
    TxOut{
        account : A
        amount : 50
    }
}
```

A에게 50을 출금한거라서 out 으로 표현이 된다.

```
TX{
    TxInput : {
        account : A
        amount : 50
    }
    TxOutput : {
        account : A
        amount : 30
    }
    TxOutput :{
        account : B
        amount : 20
    }
}
```

```
TX{
    TxInput[],
    TxOutput[],
    hash : string
}
```

TxInput 객체 안에는 서명을 이용해서 해당 account가 실제로 잔액을 가지고 있는지 확인하는 작업을 위해서서명이 필요하다.

# TX 구현하기

영수증을 가지고 TXout에 대한 내용을 알 수 있다.

```ts
// 영수증
/*
    sender : 백
    received : baekspace
    amount : 20
    signature : 0x....
*/

// 트랜잭션
/*
TransactionData : [
    TxIns:[],
    TxOuts:[
        {
            account : A
            amount : 50
        }
    ],
    hash :0001
]


TxOut {
    account : baekspace
    amount: 20
}

TransactionRoW {
    txIns?: TxIn[
        {
            txOutIndex:1 // {A:50}
        }
    ]
    txOuts!: TxOut[
        {
            account : B
            amount: 20
        },
        {
            account : A
            amount : 30
        }
    ]
    hash?: string
}
*/
```

txIns 는 TxOut을 가지고 만든다.

Bitcoin 총 발행량 지정되어있다.
50BTC
4년마다 반감기 50/2 => 25, 12.5,6.25.... > 0에 가까운 수량이 되는 시점이 있을 것이다.
마이너에대한 보상이 없어지면 채굴이 없을것 같지만
채굴 보상 + 수수료가 있다..

컴퓨터에서 소수점 계산이 힘들기 때문에 1BTC => 10^18
1사토시 = 0.000000000000000001

## TxOut

publicKey => 32byte 64글자
account => 20byte ( 앞에 12바이트 삭제) 40글자
이기 때문에 TxOut을 구현하기 전에 account 값이 40글자인지 확인한다.

## txin, txout이 배열로 받아야하는 이유

UTXO의 개념으로 1개의 객체로 가지고 있는것이 아니라 여러개의 객체를 가지고 있을 수 있기 때문에
150 // 50, 50, 50

# transactionRow

transactionRow 객체는
txIn, txOut, hash로 이루어져있는데
여기서 hash는 단순히 txIn, txOut을 이용해서 만든 해시값이라는 것 뿐만 아니라, 이로인해 변조되었는지 검증을 할 수 있다.

# Coinbase

내가 보상을 받을 account 만 있으면된다.
