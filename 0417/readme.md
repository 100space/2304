# 블록체인

디지털 기술 중하나로, 정보를 안전하게 저장하고 공유하는 방법이다.
`블록`이라는 작은 단위로 정보를 저장하고 이를 연결하여 `체인`으로 만들어서 사용한다.

한 블록의 정보가 변조되어도, 이전 블록과 이후 블록이 연결되어 있기 때문에 변경된 내용을 발견할 수 있다. 블록체인에 저장된 정보는 정보의 당사자가 아닌 제 3자도 열람이 가능하고, 수정하거나 삭제하는 것은 불가능하다.

## 트랜잭션

트랜잭션(Transaction)은 블록체인에서 데이터를 처리하고 저장하는 기본 단위이다.
블록체인 네트워크에 참여한 참가자들 중에 2개 이상의 참가자간에 일어나는 거래를 의미한다.
각각의 `노드`에서 생성되고, 다른 노드에게 전파되어 네트워크 전에체 거래 정보를 전달한다.

### 트랜잭션의 일반적인 과정

-   트랜잭션 생성
    트랜잭션은 보내는 사람, 받는사람, 전송 금액등의 정보를 포함한다.
    이 정보는 블록체인에서 공개되기 때문에 누구나 볼 수 있음. 개인정보와 같은 민감 정보는 포함되지 않는다.

-   트랜잭션 검증
    트랜잭션이 생성된 후 다른 노드들에 의해 해당 트랜잭션의 유효성을 검사한다. 검증 과정에서는 트랜잭션에 포함된 정보가 모두 유효한지를 확인하는 과정이다. 예를 들면 보내는 사람의 계좌에 잔액, 받는 사람의 주소 등 유효한 정보인지를 확인한다.

-   트랜잭션 추가
    트랜잭션이 유효하다고 검증이 되면, 해당 트랜잭션은 블록체인에 추가된다. 이때 블록체인에서 채굴(Mining)과정을 거쳐 새로운 블록을 생성하고, 해당 블록에 트랜잭션을 추가한다.

-   거래 완료
    트랜잭션이 추가된 이후에 해당 거래가 완료된다. 트랜잭션의 수수료는 채굴자에게 지급이된다.

### 트랜잭션 더블 스팬딩(Double Spending)

더블 스팬딩(Double Spending) : `이중지불`은 블록체인에서 가장 큰 문제 중 하나로, 동일한 코인을 두 번 이상 사용하는 것을 말한다.
A가 B에게 일정 코인을 전송했다가, 취소하고, 그 코인을 다시 C에게 전송하는 것이다.

중앙화 시스템에서는 발생하지 않지만, 블록체인은 분산 네트워크를 기반으로 하기 때문에 이를 막기위해서 보안 기술을 이용하여 더블 스팬딩을 방지하였는데, 가장 기본적인 방법이 트랜잭션 검증 과정이다.

트랜잭션 검증 과정에서 해당 트랜잭션이 유효한지를 확인한다. 이때 트랜잭션의 중복 사용 여부도 확인하여, 더블 스팬딩을 방지할 수 있다.

## 블록체인에서의 노드(Node)

블록체인 네트워크에 참여하며, 블록체인 데이터를 저장하고, 검증하는 컴퓨터 또는 디바이스를 의미한다. 쉽게 설명하면, 하나의 서버라고 할 수 있다.
즉, 노드는 블록체인 네트워크의 구성원이며, 블록체인의 분산 네트워크를 구성하는 요소이다.

### 노드의 역할

-   데이터 저장
    블록체인의 모든 데이터를 저장한다. 블록체인에 연결된 모든 노드에 분산저장 되며, 데이터를 안전하게 보관한다.
-   데이터 검증
    데이터를 검증하여 새로운 블록이 추가될 때, 블록이 유효한지 여부를 확인한다.
-   트랜잭션 전파
    새로운 트랜잭션이 발생하면, 이를 다른 노드에 전파한다. 이를 통해 블록체인 네트워크는 실시간으로 거래 정보를 공유하며, 이를 기반으로 새로운 블록을 생성한다.
-   블록 생성
    일부는 새로운 블록을 생성하는 채굴자(Miner) 역할을 한다. 채굴자는 블록체인의 `작업 증명(Proof of Work)` 과정을 통해 새로운 블록을 생성한다.
-   노드 간 통신
    블록체인 내에서 상호작용할 수 있도록 다른 노드와 통신을 한다. 이를 통해 블록체인 네트워크는 분산된 구조를 유지할 수 있다.

## 원장

일반적으론 회계, 재무 쪽에서 사용하는 개념으로, 기록이나 거래 정보를 저장하고, 추적하는 장부를 의미한다.

### 분산 원장

블록체인에서의 원장은 거래정보를 분산 네트워크에 저장하고, 블록으로 묶어서 체인 형태로 연결한다. 그래서 블록체인은 `분산 원장` 기술로 분류된다. 모든 거래 정보는 모든 노드에 저장되고, 이를 통해 블록체인은 위조나 조작이 불가능한 안전한 데이터베이스로 유지된다. 또한, 거래 정보 뿐 아니라 거래 정보가 생성된 시간, 거래 참여자들의 주소, 거래 금액 등 다양한 정보를 포함한다.

## 중앙화와 탈중앙화

중앙화는 하나의 중앙 관리자가 모든 결정을 내리고, 모든 기능을 제어하는 시스템이다. 일반적으로 중앙 서버나 데이터베이스가 있으며, 이를 통해 모든 사용자가 접근하고, 모든 데이터가 중앙화되어 관리된다.

탈중앙화는 중앙화의 반대의 개념으로, 하나의 중앙 관리자가 아닌 분산 시스템이다. 탈중앙화된 시스템에서는 데이터와 기능ㅇ이 분산되어 여러 노드에 저장되고, 처리된다. 이를 통해 중앙 서버나 데이터베이스에 대한 의존성이 줄어들고, 보안과 신뢰성이 향상된다.

탈중앙화를 위해서 데이터가 입력되면 전체 노드에 전달이 되어야 한다.
전달하는 과정에서 일반적으로 P2P 네트워크 구조를 사용한다.

# 비트코인

**나카모토 사토시** 라는 인물에 의해 만들어졌다.
지금까지 본인이 나카모토 사토시라는 사람이 여럿 나왔지만, 아직까지 본인임을 증명하지 못했다.

일반적으로 은행같은 곳에서 계좌번호와 비밀번호, OTP로 본인을 증명할 수 있듯, 블록체인에서도 지갑(계좌번호)과 개인키(소유주만 아는 비밀번호 같은 역할)를 이용하여 증명할 수 있지만 나카모토 사토시라고 주장한 사람들 모두 이를 이용하여 증명할 수 없었다.

## 지갑

공개키는 지갑의 주소로 누구나 확인할 수 있지만 개인키는 지갑을 이용해서 보관,관리하고 절대 공개되면 안되며 소유주가 관리하는 방식에 따라서 크게 소프트웨어로 관리하면 **콜드월렛**, 하드웨어로 관리하게 되면 **하드월렛**으로 나눌 수 있다.

## 지갑과 트랜잭션

트랜잭션을 생성 후 지갑을 이용해서 서명을 하여 블록체인 네트워크로 전송을 한다.
전송된 트랜잭션은 블록에 포함되어 블록이 원장에 추가되고 모든 노드들이 해당 블록을 동기화하여 자신의 원장에 추가한다.
그리고 블록체인 네트워크는 **원장**을 공개한다. 트랜잭션의 당사자가 아니더라도 제3자가 확인할 수 있어야한다.

## 블록 익스플로러

블록, 트랜잭션, 주소 및 정보를 조회하고 분석을 할 수 있게 해주는 도구로써 블록체인의 노드에서 데이터를 가져와서 사람이 읽을 수 있는 데이터로 구성하여 사용자에게 보여준다.

## 제네시스 블록

블록체인의 모든 블록은 이전 블록의 해시값을 참조하지만 제네시스 블록은 처음 만들어진 블록이기 때문에 이전 블록의 해시값이 없다. 일반적으로 최초 블록을 개발한 사람이 제네시스 블록을 가지고 있다.

## 해시 (Hash)

해시는 임의 크기의 데이터를 고정된 큭기의 데이터로 변환하는 과정을 말하며, 변환된 데이터를 해시 값이라고 한다. 해시 함수는 입력 데이터가 조금만 바뀌어도 출력 결과 값이 달라지게 설계되어 있다.

대부분의 블록체인은 SHA-256 해시 알고리즘을 이용하여, 256bit(32byte)의 고정 해시 값을 출력한다.

블록을 생성할 때, 트랜잭션을 포함하여 만드는데, 이 때 트랜잭션은 해시값으로 변환된 이후에 블록에 포함된다.

## 머클루트

일반적으로 하나의 블록에는 여러 개의 트랜잭션이 있는데, 여러 트랜잭션중 가까운 2개의 해시값을 조합해서 1개의 해시값을 만들고 이 상위로 올라간 2개의 해시값을 다시 조합해서 1개의 해시값으로 만든다. 토너먼트 대진표처럼 생기게 되는 데 이를 머클트리라고 하며, 이와 같은 과정을 반복하여 최종적으로 1개가 남으면, 그 최상위의 해시값이 머클루트가 된다.

해시값은 조금만 바뀌어도 출력 결과값이 달라지는 특성때문에, 이를 이용하여 트랜잭션의 무결성 검증을 할 수 있다.

## 마이닝 (채굴)

Minning은 블록체인에서 새로운 블록을 생성하는 과정을 말하며, 흔히 채굴이라고 한다.
블록체인에서 새로운 트랜잭션이 발생하면, 이를 블록에 담아서 네트워크에 전파한다. 블록을 만드는 보상으로 코인을 주며, 블록 수가 많아질수록 탈중앙화에 가까워진다.

## 블록체인 트렐레마

블록체인 트렐레마는 블록체인의 3대요소인 확장성, 보안성,탈중앙화(분산 원장) 사이의 상충 관계를 나타내는 개념이다.
이 상충 관계를 극복하기 위해서 블록체인 기술의 발전이 지속적으로 이루어 지고있다.
현재 빗썸, 업비트와 같은 거래소 같은 경우 탈중앙화가 아닌 중앙화 거래소이다. 중앙화를 하면서 거래 속도를 늘렸다. 그래서 거래소 내에서 거래를 할 때는 빠르지만, 출금하는 과정에서는 블록체인 네트워크에 블록을 생성하기 때문에 출금 속도가 느린 것이다.

# 블록체인 네트워크에 블록 추가하는 과정

1. 새로운 트랜잭션이 생성된다.
2. 채굴자는 이 트랜잭션을 포함한 블록을 생성하기 위해 마이닝을 시작한다. 블록을 생성하기 위해서는 작업증명(POW) 과정을 거쳐야한다.
3. 채굴자는 먼저 현재 블록체인에서 가장 최근에 생긴 블록의 해시 값을 알아낸다.
4. 채굴자는 블록 헤더에 3번 과정에서 얻은 해시값(이전 블록 해시값), 새로운 블록의 트랜잭션을 이용한 머클루트, 생성시간, 난이도, 채굴자의 고유한 임의의 값인 논스(Nonce)를 추가한다.
5. 채굴자는 블록의 해시값이 일정 기준 이하인지 검증하는 작업을 수행하고, 만약 기준 이상이라면 논스를 변경하여 블록의 해시값을 다시 구해서 검증한다. 기준 이하가 된다면 블록을 블록체인 네트워크에 전파한다.
6. 다른 노드들은 이 생성된 블록을 검증하고, 이전 블록과의 연결성 및 새로운 트랜잭션의 유효성을 확인한다. 모든 노드가 동의할 경우, 해당 블록이 블록체인에 추가되어 원장이 업데이트 된다.

# 객체 지향 프로그래밍(OOP)

객체 개념을 기반으로 하는 프로그래밍이다.
복잡하지만 모듈식이여서 재사용 가능하다.
객체 지향 프로그래밍을 하게 된다면 얻는 이점으로 모듈성, 재사용성, 유연성, 유지보수성이 있다.

-   모듈성 : 작고, 관리하기 쉬운 단위로 나누어서 데이터와 동작을 캡슐화하여 코드를 더 쉽게 이해하고 유지 관리 할 수 있다.
-   재사용성 : 상속과 구성을 통해 코드의 재사용성을 높였다. 기존 클래스를 확장하거나, 결합하는 클래스를 생성하여 중복 코드를 작성할 필요성을 줄일 수 있다.
-   유연성 : 요구사항에 유연하게 대처할 수 있는 코드를 만들 수 있다. 쉽게 수정 가능하고, 확장할 수 있다.
-   유지보수성 : 이해하기 쉽고 유지보수하기 쉬운 코드를 작성할 수 있다.

## 객체지향설계 5대원칙 (SOLID)

객체 지향 프로그래밍을 잘 구성하기 위해서 크게 원칙을 5가지로 나누었는데, 이를 SOLID 원칙이라고 불린다.

-   S(SRP : Single reponsibility principle) : **단일 책임 원칙**으로 한 클래스는 하나의 책임만 가져야 한다. 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는데 집중되어 있어야 한다.는 원칙이다.
-   O (OCP : Open/Closed Principle) : **개방-폐쇄의 원칙**으로 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에 열려있고, 변경에는 닫혀있어야 한다는 원리이다. 요구사항의 변경이나 추가 사항이 생기더라도, 기존 구성요소는 수정이 일어나지 말고, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야한다는 뜻이다.
-   L (LSP : Liskov Substitution Principle) : **리스코프 치환 원칙**으로 프로그램의 객체는 프로그램의 정확성에 영향을 미치지 않으면서 하위 클래스의 인스턴스로 바꿀 수 있어야한다.
-   I (ISP : Interface Segregation Principle) : **인터페이스 분리 원칙**으로 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리이다. 하나의 일반적인 인터페이스보다 여러개의 구체적인 인터페이스가 더 낫다고 정의할 수 있다.
-   D (DIP : Dependency Inversion Principle) : **의존성 역전의 원칙**으로 고수준 모듈이 저수준 모듈에 의존해서는 안된다.는 의미이다. 즉, 추상화에 의존해야지, 구체화에 의존하면 안된다.라고 할 수 있다. 의존성 주입은 이 원칙을 따른다.

## 추상화와 구체화

추상화 : 가장 중요한 것에 집중하기 위해서 시스템이나 아이디어에 풀필요한 세부 사항을 제거하는 것.
구체화 : 추상적인 아이디어나 시스템을 취하고, 이를 구체적으로 구현하는 과정이다. 구체화 하는 과정에서 세부사항을 추가하고 시스템의 특정 동작 및 속성을 정의하는 작업이 포함된다.

### 예시 1

```js
// 추상화
class Shape {
    drow() {}
    getArea() {}
}

class Square extends Shape {
    constructor(length) {
        super()
        this.length = length
    }
    draw() {}
    getArea() {
        return this.length * this.length
    }
}

//구체화
const square = new Square(5)
square.draw()
console.log(square.getArea())
```

### 예시 2

```js
//추상화
class Animal {
    constructor(name, type) {
        this.name = name
        this.type = type
    }
    speak() {}
}

class Dog extends Animal {
    constructor(name) {
        super(name, "dog")
    }
    speak() {
        return "Woof!!"
    }
}
class Cat extends Animal {
    constructor(name) {
        super(name, "cat")
    }
    speak() {
        return "Meow!"
    }
}
function makeAnimalSpeak(animal) {
    console.log(animal.name + ":" + animal.speak())
}

//구체화
const dog = new Dog("Fido")
const cat = new Cat("Whiskers")

console.log(dog.speak()) // Woof!!
console.log(cat.speak()) // Meow!

makeAnimalSpeak(dog) //Fido : Woof!!
makeAnimalSpeak(cat) // Whiskers : Meow!
```

### 예시 3

```js
class Vehicle () {
    constructor (color, brand, model){
        this.color = color
        this.brand = brand
        this.model = model
    }
    start () {

    }
}

class Car extends Vehicle{
    constructor (color, brand, model, numDoors) {
        super(color, brand, model)
        this.numDoors = numDorrs
    }
    start(){
        return "The" + this.color + " " + this. brand + " " + this.model + " starts with a key"
    }
}

class Motorcycle extends Vehicle {
    constructor (color, brnad, model){
        super(color, brnad, model)
    }
    start () {
        return "The "+this.color + " " +this.brnad + " " + this.model + " starts whit a kick-start"
    }
    function startVehicle(vehicle) {
        console.log(vehicle.start())
    }
}


//구체화

const car = new Car ("red", "Ford", "Mustang", 2)
const motorcycle = new Motorcycle ("black", "Harley Davidson", "Softail")

console.log(car.start())
console.log(motorcycle.start())

startVehicle(car) // The red Ford Mustang starts with a key
startVehicle(motorcycle) // The black Harley Davidson Softail starts with a kick-start
```
