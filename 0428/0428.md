100개까지 만들었던 블럭은 chain의 이론에 가깝다.
현재 내 기준에서 10번째 전 블럭을 가져오는 메서드, 블럭을 추가하는 과정및 검증에 대한 내용이 있을 것이다.

블록 -> 체인 -> 통신 -> p2p -> 트랜잭션 -> 지갑
블록 -> 트렌잭션 -> 체인 -> 통신,p2p -> 지갑

# 트랜잭션

블록을 생성할 때 data를 스트링으로 넣었지만 원래는 트랜잭션들로 만들어야 한다.

```ts
const block1 = block.createBlock(GENESIS, "123123", GENESIS)
```

트랜잭션을 이해하려면 서명에 대해서 알아야 한다.
서명 - 자신임을 증명하는 것이다.

온라인에서 나를 증명하는 방법.. 로그인이다. 이유는 패스워드를 나만알고 있기때문이다.

블록체인의 기본적으로 나를 증명하는 방법은 패스워드랑 비슷하지만 절대 DB에 저장하지 않는다.
저장하지 않아도 수학적으로 계산하는 과정을 통해서 나임을 증명한다.

전자서명 - 개인키, 공개키를 이용한 암호화

대칭 암호화
비대칭 암호화

암호화키 : 평문을 암호화를 할 때, 암호화된 텍스트를 평문으로 바꿀때, 필요한 도구로서 컴퓨터에선 일반적으로 32byte로 이루어진 데이터로 되어있다.

암호화할 떄는 비밀키를 이용하고, 복호화할 때는 공개키를 이용한다.
비밀키와 공개키는 쌍으로 이루어져있고, 이 쌍을 키페어라고 한다.
비밀키와 공개키는 서로 같지 않은 값으로 이루어져있다.

비대칭키에서 양방향,단방향으로 나누는 기준은 암호값을 복호화가 되느냐 안되느냐에 따라 다르다.
양방향은 복호화가 되고, 단방향은 복호화가 되지 않는다.

블록체인은 비대칭키 - 단방향 암호화가 된다.

공개키와 비밀키는 키페어이기 때문에 비밀키를 이용해서 암호화를 한다면 공개키를 이용해서 직접적인 복호화를 하는 것이 아닌 자기(공개키)랑 키페어인 비밀키로 암호화를 했다는 것을 증명할 수 있다.

## 비트코인네트워크에서 A가 B에게 BTC를 전송할 때 생기는 문제

1. a가 10 btc를 가지고 있을 때 , b에게 2btc를 주려고 할 때 ,
   a가 네트워크에 데이터를 보내야한다. 보내기 전에 bitcoin네트워크는 a가 실제로 10btc를 가지고 있다는 걸 검증해야한다.
2. a한테 8btc를 다시 주고, b한테 2btc를 줄 떄 , a가 본인인지 확인을 해야한다.

비트코인 네트워크에는 사용자가 저장되어있지 않다. 하지만 증명을 해야한다. 증명을 하는 과정을 잘 알아야한다.

A라는 사람이 B라는 사람에게 2btc를 줄 때, 영수증 같은 영역(객체)에 주고 받을 사람의 지갑주소, 전송할 정보, 서명을 담아서 bitcoin네트워크로 보낸다.

bitcoin네트워크에서는 서명을 검증한다. 검증이 통과되면 거래를 위한 데이터가 생긴다.

영수증이 평문으로 되어 있고, 서명부분이 암호화로 되어있다.
a라는 사람은 개인키(비밀키)를 가지고 있어야 한다. 그 개인키를 이용해서 서명을 해서 영수증을 완성하고
이를 비트코인네트워크에 보낸다.

비트코인은 영수증이 맞는지 틀리는지 확인을 위해서 서명을 비트코인네트워크에서 가지고 있는 공개키를 이용해서 검증하는 과정을 가지고, 이 검증과정에서 맞다 아니다 정도의 결과값이 나오면 참일 경우 거래를 진행한다.

개인키로 암호화했기 때문에 공개키로 검증을 할 수 있다.

트랜잭션은 영수증(객체)를 만들기 위한 작업부터 시작된다.

# 개인키

개인키를 가지고 있으면 키페어를 이루는 공개키도 만들어야한다.

개인키를 만드는 방법은 간단하다.
예를 들어 동전을 256번을 던져서 앞뒤를 기록하면 그게 256bit, 32byte이다.
공개키는 수학적 기술을 통해서 공개키를 만든다.그 수학적 암호기술을 SECP256K1 암호 알고리즘이다.

메타마스크의 주된 기능은 개인키를 입력하고, 어디 네트워크인지를 표시해주면 통신을 해서
하드디스크 어딘가의 개인키를 이용해서 서명하고 트랜잭션을 발동한다.

# 블록체인 네트워크

영수증을 만들어 blockchain 네트워크에 거래를 요청했을 때, 영수증의 검증을 받고 검증이 끝나면 트랜잭션을 만들고, 트랜잭션을 트랜잭션 풀에 담아둔다.

마이닝을 할 때, 정보를 기입하고 필요한 트랜잭션 내용을 풀에서 받아서 작업을 진행한다. 트랜잭션들을 이용하여 머클루트를 만들고 이를 이용해서 블록을 생성한다.

# 나의 잔액을 아는 방법

블록에 트랜잭션 내용이 담겨있다. 나의 입금과, 출금 내역이 다 있다.
트랜잭션에 이용하지 않는 내역들을 모아놓은 것이 UTXO이다.

# 암호화에 관한 코드를 작성

## 개인키를 만드는 방법으로

js의 내장모듈인 crypto를이용하여 randomBytes 메서드를 사용한다.

```ts
  createPrivateKey() {
        return randomBytes(32).toString("hex")
    }
```

## 공개키 만드는 방법

개인키를 이용하여 수학적 알고리즘을 이용하여 만드는데,
이 때 알고리즘을 구현해놓은 라이브러리가 있다. elliptic 라이브러리를 이용하여 공개키를 만들 수 있다.

```ts
createPublicKey(privateKey: string) {
        const keyPair = this.ec.keyFromPrivate(privateKey)
        const publicKey = keyPair.getPublic().encode("hex", true) //32byte + 1byte

        return publicKey // 32byte
    }
```

# 서명하기와 검증하기

sign(), verify()함수를 이용하여 서명할 떄, 평문의 데이터가 있어야한다.
검증할 기준이 되는 데이터가 있어야하기 때문에 각각 평문의 데이터가 있어햐한다. 그래서 영수증에 대한 인터페이스를 구축해야한다.

```ts
export class Receipt {
    sender!: string
    received!: string
    amount!: string
    signature?: unknown
}
```

서명을 하기 위해서는 개인키와 데이터(평문)이 있어야한다.

개인키는 공인인증서, 공개키는 계좌 비밀번호의 개념이다.
account를 알고있으면 공개키를 알 수 있고, 이 공개키를 이용해서 개인키와 검증한다.

이더리움 기준으로 account 만드는 규칙은 32byte에서 12byte를 잘라서 20byte로 만든다.
지금 현재 로직에서 publicKey가 33byte이기 때문에 13byte를 잘라야한다. (26글자)

개인키를 블록체인네트워크에서 알수 없기 떄문에 검증이 안되서 잘못적으면 내돈을 날리는 것이다.
장점은 개인키를 안가지고 있기 때문에 보안성이 좋다.
